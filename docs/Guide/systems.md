---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(Guide-systems)=
# Defining molecular systems

Before diving into any computational chemistry simulation, you need to answer two key questions: *What* are you studying, and *what* do you want to do with it? In other words, you have to define the **system** and the **type of calculation** that you need to run.

To help with the first part, describing the **system**, the `spycci.systems` submodule has you covered. This submodule provides a set of classes designed to organize and store information about the chemical system you're working with. Currently the following objects have been implemented:

This submodule provides a set of classes designed to organize and store information about the chemical system you're working with. Currently the following objects have been implemented:

* [The `System` class:](system-section) a general-purpose object representing a single molecular system or aggregates.
* [The `ReactionPath` class:](reactionpath-section) a collection of closely related `System` objects as a path in the configuration space. For example, a set of intermediate and transition states structures (e.g. from reactants to products).
* [The `Ensemble` class:](ensamble-section) a collection of closely related `System` objects representing a physical ensemble. For example, a set of conformers generated by the **CREST** tool.

You can bring these classes into your project using the syntax:

```
from spycci.systems import System
from spycci.systems import Ensemble
```

In this section of the guide, we'll show you how to define molecular systems using these classes, their features and the most useful mode of operation.

---

(system-section)=
## Single systems: The use of the `System` class

A `System` object represents a molecular system containing one or more individual molecules. A `System` object, as a real molecular system, is defined by a series of attributes:

* `name`: the name of the system. (type: `str`)
* `geometry`: the 3D molecular geometry of the system encoding the position of each atom in space. (type: `MolecularGeometry`)
* `charge`: the total charge of the system. (type: `int`)
* `spin`: the spin multiplicity of the system as $2S+1$, where $S$ is the total spin quantum number. (type: `int`)
* `box_size`: for periodic systems the size of the cubic periodic boundary conditions box. (type: `float`)

Furthermore each system is associated with a set of `properties` that are set and accessed during computational chemistry calculations and workflows. We will cover these in [subsequent chapters of this user guide](Guide-properties).

:::{admonition} Important note about syntax
:class: warning
The `MolecularGeometry` and the `Properties` classes represent the two central elements of the `SPyCCI` library architecture and have been built with two principles in mind: 1) Ensure that the data stored within each object is protected from accidental/unwanted writing operations from the user, 2) Ensure that there is always a valid relation between the currently stored data and the state of the system (e.g. if the geometry of the system is changed by the user the properties computed for the old geometry must be deleted).

This directly translate to well defined syntax rules that can be summarized as: **all properties of the `MolecularGeometry` and `Properties` classes can be accessed via the property getter but can be set ONLY using a C-like setter function named as `set_name()` where `name` is the name of the propery we want to set.** In other terms, each mutable property of the `MolecularGeometry` and `Properties` classes are returned as a `deepcopy` of the stored data; no reference is given user-side.

For example if we want to access the list of `atoms` stored in the `geometry` argument of a `system` object (of type `System`), the syntax `system.geometry.atoms` can be used. However, if we want to set the atoms list we must use the `set_atoms()` function. Trying to set the the atoms list using the syntax `system.geometry.atoms = ...` or even `system.geometry.atoms[0] = ...` **will not work**.
:::


### Loading data from an `.xyz` file

A `System` object can be initialized in various ways the most common of which is that of providing a molecular structure via a `.xyz` file. This can be done using the `from_xyz()` classmethod. In the following example a system object, containing the structure of the water molecule, is loaded from the `water.xyz` file and some of its properies are printed:

```{code-cell} python
from spycci.systems import System

# Create a System object for a neutral water molecule from a `.xyz` file
mol = System.from_xyz("../example_files/water.xyz")

# Print some attributes
print(f"Name: {mol.name}")
print(f"Charge: {mol.charge}")
print(f"Spin multiplicity: {mol.spin}")
print(f"Number of atoms: {mol.geometry.atomcount}")
print(f"Atoms list: {mol.geometry.atoms}")
```

Please notice how the `name` of the molecule has been set using the path basename stripping the `.xyz` file extension and the unspecified attributes have been set to default values:

* `charge`: total charge of the system. Default: `0`(not charged)
* `spin`: total spin multiplicity of the system. Default: `1` (singlet)
* `box_side`: length of the cubic simulation box (in $\mathrm{Å}$). Default: `None` (non periodic)

These can of course be specified explicilty in the constructor when needed. For example, a periodic system of side $\mathrm{18.27Å}$ containing a radical cation can be defined according to:

```python
from spycci.systems import System
my_mol = System.from_xyz(
    "path/to/xyz/water.xyz", 
    charge=1, 
    spin=2,
    box_side=18.27,
)
```

### Creating a `System` object form a SMILES string

Another convenient way to initialize a `System` object is that of using **S**implified **M**olecular **I**nput **L**ine **E**ntry **S**ystem (SMILES) strings. This can be done using the `form_smiles` class method providing both a `name` for the system and the SMILES string. As an example the `System` object representing a ethanol molecule can be derived from is smile `CCO` according to:


```{code-cell} python
from spycci.systems import System

mol = System.from_smiles("ethanol", "CCO")

# Print some attributes
print(f"Name: {mol.name}")
print(f"Charge: {mol.charge}")
print(f"Spin multiplicity: {mol.spin}")
print(f"Number of atoms: {mol.geometry.atomcount}")
print(f"Atoms list: {mol.geometry.atoms}")
```

The class constructor automatically adds implicit hydrogens to the structure, embeds it in the 3D space and runs a rough geometry optimization using either the `MMFF`s or the `UFF` force fields. Additional optional keywords that can be used to configure the SMILES translation process can be found in the [`System` object API](API-systems). 

### Saving an loading a `System` to and form a `.json` file

Once created, a `System` object, together with all its computed properties and attributes, can be saved to a standardized `.json` file. This can be done using the method `save_json` providing the path to the destination file. The syntax of the command is simple and can be examined in the following example:

```python
from spycci.systems import System

mol = System.from_xyz("water.xyz")

# ... SOME CALCULATION CAN BE DONE HERE ...

mol.save_json("water.json")
```

The saved `.json` file contains all the information of the `System` object and can be used to rebuild the same object at a later time. This can be done using the `from_json()` classmethod according to:

```python
from spycci.systems import System

mol = System.from_json("water.json")
print(mol)
```

```{code-cell} python
:tags: ["remove-input"]
from spycci.systems import System
water = System.from_json("../example_files/water.json")
print(water)
```

### Creating a `System` manually from coordinates

The most basic approach to create a `System` object is that of manually entering the coordinates of each atom in the molecule. This approach is rarely used by the computational chemistry practitioner but, not involving the use of external files, finds large applications in developing new library features. The workflow is quite simple an involves the creation of a [`MolecularGeometry` object](core-geometry-API) that can be directly fed to the `System` constructor. As an example the following script can be used to generate a water molecule system directly from coordinates.

```{code-cell} python
from spycci.systems import System
from spycci.core.geometry import MolecularGeometry

WATER = [
    ["O", -5.02534, 1.26595, 0.01097],
    ["H", -4.05210, 1.22164, -0.01263],
    ["H", -5.30240, 0.44124, -0.42809],
]

# Creating a MolecularGeometry onject
water = MolecularGeometry()
for l in WATER:
    water.append(l[0], l[1::])

# Creating the `System` object from the generated geometry
mol = System("water", geometry=water)

# Print some attributes
print(f"Name: {mol.name}")
print(f"Charge: {mol.charge}")
print(f"Spin multiplicity: {mol.spin}")
print(f"Number of atoms: {mol.geometry.atomcount}")
print(f"Atoms list: {mol.geometry.atoms}")
```

Please notice how this approach is the only one relaying directly on the `__init__` method of the `System` class. In fact, all the classmethods explored so far simply generate a `MolecularGeometry` object that is then fed to the `__init__` method. 

---

(reactionpath-section)=
## ReactionPath

A `ReactionPath` object is defined as an ordered collection of related `System` objects representing consecutive geometries along a reaction coordinate, for example the images of a NEB or IRC calculation. To initialise an `ReactionPath` object you need to provide an `iterable` (such as a list) yielding `System` objects:

```python
from spycci.systems import System
from spycci.systems import ReactionPath

my_mol1 = System.from_xyz("path/to/xyz/my_mol1.xyz")
my_mol2 = System.from_xyz("path/to/xyz/my_mol2.xyz")
my_mol3 = System.from_xyz("path/to/xyz/my_mol3.xyz")

my_list = [my_mol1, my_mol2, my_mol3]

my_ens = ReactionPath(my_list)
```

To get a list of all the available properties and attributes, please refer to the [API](API-systems).

### Slicing a `ReactionPath` object

The `ReactionPath` class exposes an `__iter__` and `__getitem__` method returning the reference to the systems stored in the inner `systems` attribute. As such a subset/section of a reaction path can easily be accessed by index slicing:

```{code-cell} python
from spycci.systems import System
from spycci.systems import ReactionPath
from spycci.core.geometry import MolecularGeometry

frames = []
for i in range(5):
    geom = MolecularGeometry()
    geom.append("H", [0., 0., 0.])
    geom.append("H", [0.25*i, 0., 0.])
    frame = System(f"mol{i}", geom)
    frames.append(frame) 


path = ReactionPath(frames)
print("Original path")
print("[" + ", ".join([s.name for s in path]) + "]\n")

path = ReactionPath(path[1:4])
print("Path after slicing")
print("[" + ", ".join([s.name for s in path]) + "]\n")
```

### Interpolating a `ReactionPath` object

The `ReactionPath` class also implements internal methods to automatically interpolate the reaction path, addig new frames or redistributing the existing ones. This can be done using the `interpolate` function. As an example consider the following code in which a generic path composed of 3 frames is interpolated to generate a 5 frames `ReactionPath` object:

```{code-cell} python
from spycci.systems import System
from spycci.systems import ReactionPath
from spycci.core.geometry import MolecularGeometry

frames = []
for i in range(3):
    geom = MolecularGeometry()
    geom.append("H", [0., 0., 0.])
    geom.append("H", [0.25*i, 0., 0.])
    frame = System(f"mol{i}", geom)
    frames.append(frame) 


path = ReactionPath(frames, name="mypath")
print("Original path")
print("[" + ", ".join([s.name for s in path]) + "]\n")

path = path.interpolate(5)
print("Path after interpolate")
print("[" + ", ".join([s.name for s in path]) + "]\n")
```

As can be seen during the operation, the name of each frame has been set to the name of the path plus a `_interp_IDX` suffix indicating the origin of the newly generated frame.

#### How does the `interpolate` function works?

The interpolation process begins by reshaping the coordinates of each frame into a coordinate matrix $\mathbf{C}$ of dimension $(M, 3N)$, where $N$ is the number of atoms and $M$ is the number of frames (or systems) in the original path. The matrix $\mathbf{C}$ can be written as:

$$
\mathbf{C} := 
\begin{pmatrix}
x_1^{(1)} & y_1^{(1)} & z_1^{(1)} & x_2^{(1)} & \cdots & z_N^{(1)}  \\
x_1^{(2)} & y_1^{(2)} & z_1^{(2)} & x_2^{(2)} & \cdots & z_N^{(2)}  \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
x_1^{(M)} & y_1^{(M)} & z_1^{(M)} & x_2^{(M)} & \cdots & z_N^{(M)}  \\
\end{pmatrix}
=
\begin{pmatrix}
\mathbf{x}^{(1)} \\
\mathbf{x}^{(2)} \\
\vdots \\
\mathbf{x}^{(M)}
\end{pmatrix}
$$

where each $\mathbf{x}^{(i)} = (x_1^{(i)}, y_1^{(i)}, z_1^{(i)}, \ldots, z_N^{(i)})$ represents the flattened coordinate vector of the $i$-th frame. Once all coordinates are collected in $\mathbf{C}$, the difference between consecutive frames is computed, yielding a new matrix $\boldsymbol{\Delta}$ of dimension $(M - 1, 3N)$:

$$
\boldsymbol{\Delta} := 
\begin{pmatrix}
\mathbf{x}^{(2)} - \mathbf{x}^{(1)} \\
\mathbf{x}^{(3)} - \mathbf{x}^{(2)} \\
\vdots \\
\mathbf{x}^{(M)} - \mathbf{x}^{(M-1)}
\end{pmatrix}
$$

The Euclidean norm of each row of $\boldsymbol{\Delta}$ is then evaluated to obtain the vector of inter-frame distances $\boldsymbol{\delta}$:

$$
\boldsymbol{\delta} :=
\begin{pmatrix}
\delta_2 \\
\delta_3 \\
\vdots \\
\delta_M
\end{pmatrix}
=
\begin{pmatrix}
\lVert \mathbf{x}^{(2)} - \mathbf{x}^{(1)} \rVert \\
\lVert \mathbf{x}^{(3)} - \mathbf{x}^{(2)} \rVert \\
\vdots \\
\lVert \mathbf{x}^{(M)} - \mathbf{x}^{(M-1)} \rVert
\end{pmatrix}
$$

where each $\delta_i$ represents the Euclidean distance between consecutive frames $i$ and $i-1$. From this, the **reaction coordinate** vector $\mathbf{S}$ can be defined as the cumulative sum of the inter-frame distances:

$$
\mathbf{S} :=
\begin{pmatrix}
0 \\
\delta_2 \\
\delta_2 + \delta_3 \\
\vdots \\
\delta_2 + \delta_3 + \cdots + \delta_M
\end{pmatrix}
$$

Finally, a new, evenly spaced reaction coordinate vector $\mathbf{r_c}$ of length $M'$ is generated.  
Each column of $\mathbf{C}$ (corresponding to a Cartesian component of a specific atom) is then **linearly interpolated** along $\mathbf{S}$ using the `numpy.interp` function, with $\mathbf{S}$ as the *x*-values and the coordinates as the *y*-values. The result is a new coordinate matrix $\mathbf{C}'$ of dimension $(M', 3N)$, representing the interpolated atomic positions along the new path.

:::{admonition} Note about endpoints
:class: warning
Please notice how, by performing a linear interpolation, the path endopoints are not fixed. As such by interpolating a reaction path going from the equilibrium structure of a reagent to the one of the product, a mimatch between ending-point can be seen for highly non-linear atom trajectories.
:::

### Analyzing active atoms along a reaction path

The `ReactionPath` class also implements an `analyze_active_atoms` function designed to provide an easy tool to examine the atoms active along a reaction path. The function returns the standard deviation matrix of each atom coordinate along the path and the **total spatial standard deviation** for each atom. As an example consider the following code:

```{code-cell} python
from spycci.systems import System
from spycci.systems import ReactionPath
from spycci.core.geometry import MolecularGeometry

frames = []
for i in range(4):
    geom = MolecularGeometry()
    geom.append("Cl", [0., 0., 0.])
    geom.append("H", [0.5*(i+1), 0., 0.])
    geom.append("Br", [2.5, 0., 0.])
    frame = System(f"mol{i}", geom)
    frames.append(frame) 


path = ReactionPath(frames)
std, norm = path.analyze_active_atoms()

print("Standard deviation matrix:")
print(std)
print()

print("Total spatial standard deviation:")
print(norm)
print()

i = norm.tolist().index(max(norm))
j = std[i, :].tolist().index(max(std[i, :]))
axes = ["x", "y", "z"]
print(f"The atom moving the most is {geom.atoms[i]} along the {axes[j]} axis.")
```


#### How does the `analyze_active_atoms` function works?

The idea behind the `analyze_active_atoms` function is simple. For each coordinate component $\xi \in [x, y, z]$ of each atoms $i$ the standard deviation $\sigma_{\xi_i}$ is computed along the path frames leading to a (N x 3) **standard deviation matrix** $\mathbf{\Sigma}$:

$$
\mathbf{\Sigma} = \begin{pmatrix} 
\sigma_{x_1} & \sigma_{y_1} & \sigma_{z_1} \\
\sigma_{x_2} & \sigma_{y_2} & \sigma_{z_2} \\
\vdots & \vdots & \vdots \\
\sigma_{x_N} & \sigma_{y_N} & \sigma_{z_N} \\
\end{pmatrix} = \begin{pmatrix}
\boldsymbol{\sigma}_1 \\
\boldsymbol{\sigma}_2 \\
\vdots \\
\boldsymbol{\sigma}_N
\end{pmatrix} \qquad \text{with} \qquad 
\sigma_{\xi_i} = \sqrt{\frac{1}{M} \sum_{j=0}^M {\left(\xi_i^{(j)} - \bar{\xi}_i\right)^2}}
$$

where $\xi_i^{(j)}$ represents the coordinate $\xi$ of the $i$-th atom in the $j$-th frame while $\bar{\xi}_i$ its average (frame-wise) along the path. From this standard deviation matrix, the Euclidian norm $d_i = \lVert \boldsymbol{\sigma}_i \rVert$ of the standard deviation vector $\boldsymbol{\sigma}_i$ of each atom is computed returning an estimate of the the **total spatial standard deviation** (in Å) associated with each atom in a path.

$$
d_j = \lVert \boldsymbol{\sigma}_i \rVert = 
\sqrt{
\sigma_{x_i}^2 + \sigma_{y_i}^2 + \sigma_{z_i}^2
},
\quad j = 1, 2, \ldots, N.
$$

---

(ensamble-section)=
## Ensembles

An `Ensemble` object is defined as a collection of related `Systems`, representing a physical ensemble, for example a set of structures sampling a thermal distribution or different conformational states. To initialise an `Ensemble` object you need to provide an `iterable` (such as a list) yielding `System` objects:

at this stage, the example of usage is equivalent to the `ReactionPath` class:

```python
from spycci.systems import System
from spycci.systems import ReactionPath

my_mol1 = System.from_xyz("path/to/xyz/my_mol1.xyz")
my_mol2 = System.from_xyz("path/to/xyz/my_mol2.xyz")
my_mol3 = System.from_xyz("path/to/xyz/my_mol3.xyz")

my_list = [my_mol1, my_mol2, my_mol3]

my_ens = Ensemble(my_list)
```

To get a list of all the available properties, please refer to the [API](API-systems).

<!-- 
---

## Molecular Dynamics Trajectories

:::{admonition} Note
:class: info
This is still very much WIP! Expect the following content to possibly be changed significantly with future updates!
:::

An `MDTrajectory` object is conceptually an `Ensemble` generated by a Molecular Dynamics (MD) trajectory. Currently, only [DFTB+](API-wrappers-dftbplus) MD are supported. `MDTrajectory` objects are initialised by providing the path `prefix` to the `<prefix>_md.out` file storing the energy information and `<prefix>_geo_end.xyz` file storing the coordinate information, and the level of theory at which the DFTB+ simulation was ran:

```python
from spycci.systems import MDTrajectory

# note, the following files must exist:
# path/to/xyz/my_traj_md.out
# path/to/xyz/my_traj_geo_end.xyz
my_traj = MDTrajectory("path/to/xyz/my_traj", "gfn2")
```

The primary intended use for this class is as an on-the-fly generator of `System` objects corresponding to the requested frame of the MD simulation. 

Examples:

* Extract the last frame of the MD simulation as a System object:
```python
last_frame = my_traj[-1]
```
* Cycle over all frames and export the corresponding .xyz files:
```python
for frame in my_traj:
    frame.write_xyz(frame.name)
```

Note: individual "frames" are automatically internally renamed according to the corresponding step/index of the MD simulation.  -->